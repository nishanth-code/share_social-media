/// <reference types="react" />

import {ArraySchemaType} from '@sanity/types'
import type {ComponentType} from 'react'
import {Descendant} from 'slate'
import {Node as Node_2} from 'slate'
import {ObjectSchemaType} from '@sanity/types'
import {Observable} from 'rxjs'
import {Operation} from 'slate'
import {Path} from '@sanity/types'
import {PropsWithChildren} from 'react'
import {default as React_2} from 'react'
import {ReactEditor} from '@sanity/slate-react'
import {Subject} from 'rxjs'

export declare type BlurChange = {
  type: 'blur'
}

/**
 * Try to compact a set of patches
 *
 */
export declare function compactPatches(patches: Patch[]): Patch[]

export declare type createEditorOptions = {
  portableTextEditor: PortableTextEditor
}

export declare type DecPatch = {
  path: Path
  origin?: Origin
  type: 'dec'
  value: JSONValue
}

export declare type DiffMatchPatch = {
  path: Path
  type: 'diffMatchPatch'
  origin?: Origin
  value: string
}

export declare interface EditableAPI {
  activeAnnotations: () => PortableTextBlock[]
  addAnnotation: (
    type: Type,
    value?: {
      [prop: string]: any
    }
  ) =>
    | {
        spanPath: Path
        markDefPath: Path
      }
    | undefined
  blur: () => void
  delete: (selection: EditorSelection, options?: EditableAPIDeleteOptions) => void
  findByPath: (path: Path) => [PortableTextBlock | PortableTextChild | undefined, Path | undefined]
  findDOMNode: (element: PortableTextBlock | PortableTextChild) => Node | undefined
  focus: () => void
  focusBlock: () => PortableTextBlock | undefined
  focusChild: () => PortableTextChild | undefined
  getSelection: () => EditorSelection
  getValue: () => PortableTextBlock[] | undefined
  hasBlockStyle: (style: string) => boolean
  hasListStyle: (listStyle: string) => boolean
  insertBlock: (
    type: Type,
    value?: {
      [prop: string]: any
    }
  ) => Path
  insertChild: (
    type: Type,
    value?: {
      [prop: string]: any
    }
  ) => Path
  isCollapsedSelection: () => boolean
  isExpandedSelection: () => boolean
  isMarkActive: (mark: string) => boolean
  isVoid: (element: PortableTextBlock | PortableTextChild) => boolean
  marks: () => string[]
  redo: () => void
  removeAnnotation: (type: Type) => void
  select: (selection: EditorSelection) => void
  toggleBlockStyle: (blockStyle: string) => void
  toggleList: (listStyle: string) => void
  toggleMark: (mark: string) => void
  undo: () => void
}

export declare interface EditableAPIDeleteOptions {
  mode?: 'blocks' | 'children' | 'selected'
}

export declare type EditorChange =
  | BlurChange
  | ErrorChange
  | FocusChange
  | InvalidValue
  | LoadingChange
  | MutationChange
  | PatchChange
  | ReadyChange
  | RedoChange
  | SelectionChange
  | UndoChange
  | UnsetChange
  | ValueChange

export declare type EditorChanges = Subject<EditorChange>

export declare type EditorNode = Node_2 & {
  _key: string
  _type: string
}

export declare type EditorSelection = {
  anchor: EditorSelectionPoint
  focus: EditorSelectionPoint
} | null

export declare type EditorSelectionPoint = {
  path: Path
  offset: number
}

export declare type ErrorChange = {
  type: 'error'
  name: string
  level: 'warning' | 'error'
  description: string
  data?: any
}

export declare type FocusChange = {
  type: 'focus'
}

export declare function getPortableTextFeatures(
  portabletextType: ArraySchemaType<PortableTextBlock>
): PortableTextFeatures

declare interface History_2 {
  redos: HistoryItem[]
  undos: HistoryItem[]
}
export {History_2 as History}

export declare type HistoryItem = {
  operations: Operation[]
  timestamp: Date
}

export declare type HotkeyOptions = {
  marks?: Record<string, string>
  custom?: Record<string, (event: React.BaseSyntheticEvent, editor: PortableTextEditor) => void>
}

export declare type IncPatch = {
  path: Path
  origin?: Origin
  type: 'inc'
  value: JSONValue
}

export declare type InsertPatch = {
  path: Path
  origin?: Origin
  type: 'insert'
  position: InsertPosition_2
  items: JSONValue[]
}

declare type InsertPosition_2 = 'before' | 'after' | 'replace'
export {InsertPosition_2 as InsertPosition}

export declare type InvalidValue = {
  type: 'invalidValue'
  resolution: InvalidValueResolution | null
  value: PortableTextBlock[]
}

export declare type InvalidValueResolution = {
  patches: Patch[]
  description: string
  action: string
  item: PortableTextBlock[] | PortableTextBlock | PortableTextChild | undefined
}

export declare type JSONValue =
  | number
  | string
  | boolean
  | {
      [key: string]: JSONValue
    }
  | JSONValue[]

export declare const keyGenerator: () => string

export declare interface ListItem extends TextBlock {
  listItem: string
  level: number
}

export declare type LoadingChange = {
  type: 'loading'
  isLoading: boolean
}

export declare type MarkDef = {
  _key: string
  _type: string
}

export declare type MutationChange = {
  type: 'mutation'
  patches: Patch[]
}

export declare type OnBeforeInputFn = (event: Event) => void

export declare type OnCopyFn = (
  event: React.ClipboardEvent<HTMLDivElement | HTMLSpanElement>
) => undefined | any

export declare type OnPasteFn = (arg0: {
  event: React.ClipboardEvent
  path: Path
  portableTextFeatures: PortableTextFeatures
  type: ArraySchemaType<PortableTextBlock>
  value: PortableTextBlock[] | undefined
}) => OnPasteResultOrPromise

export declare type OnPasteResult =
  | {
      insert?: PortableTextBlock[]
      path?: Path
    }
  | undefined

export declare type OnPasteResultOrPromise = OnPasteResult | Promise<OnPasteResult>

export declare type Origin = 'remote' | 'local' | 'internal'

export declare type Patch =
  | SetPatch
  | SetIfMissingPatch
  | UnsetPatch
  | InsertPatch
  | DiffMatchPatch
  | IncPatch
  | DecPatch

export declare type PatchChange = {
  type: 'patch'
  patch: Patch
}

export declare type PatchObservable = Observable<{
  patches: Patch[]
  snapshot: PortableTextBlock[] | undefined
}>

export declare type PortableTextBlock = {
  _type: string
  _key: string
  [other: string]: any
}

export declare type PortableTextChild =
  | {
      _key: string
      _type: string
      [other: string]: any
    }
  | TextSpan

export declare const PortableTextEditable: React_2.ForwardRefExoticComponent<
  Pick<
    PortableTextEditableProps & Omit<React_2.HTMLProps<HTMLDivElement>, 'onPaste' | 'as'>,
    | 'name'
    | 'title'
    | 'type'
    | 'readOnly'
    | 'hidden'
    | 'placeholder'
    | 'span'
    | 'children'
    | 'style'
    | 'list'
    | 'selected'
    | 'value'
    | 'action'
    | 'onChange'
    | 'start'
    | 'cite'
    | 'data'
    | 'form'
    | 'label'
    | 'slot'
    | 'summary'
    | 'pattern'
    | 'contentEditable'
    | 'draggable'
    | 'color'
    | 'onClick'
    | 'onDragStart'
    | 'onDragOver'
    | 'default'
    | 'key'
    | 'defaultChecked'
    | 'defaultValue'
    | 'suppressContentEditableWarning'
    | 'suppressHydrationWarning'
    | 'accessKey'
    | 'className'
    | 'contextMenu'
    | 'dir'
    | 'id'
    | 'lang'
    | 'nonce'
    | 'tabIndex'
    | 'translate'
    | 'radioGroup'
    | 'role'
    | 'about'
    | 'datatype'
    | 'inlist'
    | 'prefix'
    | 'property'
    | 'resource'
    | 'typeof'
    | 'vocab'
    | 'autoCapitalize'
    | 'autoCorrect'
    | 'autoSave'
    | 'itemProp'
    | 'itemScope'
    | 'itemType'
    | 'itemID'
    | 'itemRef'
    | 'results'
    | 'security'
    | 'unselectable'
    | 'inputMode'
    | 'is'
    | 'aria-activedescendant'
    | 'aria-atomic'
    | 'aria-autocomplete'
    | 'aria-busy'
    | 'aria-checked'
    | 'aria-colcount'
    | 'aria-colindex'
    | 'aria-colspan'
    | 'aria-controls'
    | 'aria-current'
    | 'aria-describedby'
    | 'aria-details'
    | 'aria-disabled'
    | 'aria-dropeffect'
    | 'aria-errormessage'
    | 'aria-expanded'
    | 'aria-flowto'
    | 'aria-grabbed'
    | 'aria-haspopup'
    | 'aria-hidden'
    | 'aria-invalid'
    | 'aria-keyshortcuts'
    | 'aria-label'
    | 'aria-labelledby'
    | 'aria-level'
    | 'aria-live'
    | 'aria-modal'
    | 'aria-multiline'
    | 'aria-multiselectable'
    | 'aria-orientation'
    | 'aria-owns'
    | 'aria-placeholder'
    | 'aria-posinset'
    | 'aria-pressed'
    | 'aria-readonly'
    | 'aria-relevant'
    | 'aria-required'
    | 'aria-roledescription'
    | 'aria-rowcount'
    | 'aria-rowindex'
    | 'aria-rowspan'
    | 'aria-selected'
    | 'aria-setsize'
    | 'aria-sort'
    | 'aria-valuemax'
    | 'aria-valuemin'
    | 'aria-valuenow'
    | 'aria-valuetext'
    | 'dangerouslySetInnerHTML'
    | 'onCopyCapture'
    | 'onCut'
    | 'onCutCapture'
    | 'onPasteCapture'
    | 'onCompositionEnd'
    | 'onCompositionEndCapture'
    | 'onCompositionStart'
    | 'onCompositionStartCapture'
    | 'onCompositionUpdate'
    | 'onCompositionUpdateCapture'
    | 'onFocus'
    | 'onFocusCapture'
    | 'onBlur'
    | 'onBlurCapture'
    | 'onChangeCapture'
    | 'onBeforeInputCapture'
    | 'onInput'
    | 'onInputCapture'
    | 'onReset'
    | 'onResetCapture'
    | 'onSubmit'
    | 'onSubmitCapture'
    | 'onInvalid'
    | 'onInvalidCapture'
    | 'onLoad'
    | 'onLoadCapture'
    | 'onError'
    | 'onErrorCapture'
    | 'onKeyDown'
    | 'onKeyDownCapture'
    | 'onKeyPress'
    | 'onKeyPressCapture'
    | 'onKeyUp'
    | 'onKeyUpCapture'
    | 'onAbort'
    | 'onAbortCapture'
    | 'onCanPlay'
    | 'onCanPlayCapture'
    | 'onCanPlayThrough'
    | 'onCanPlayThroughCapture'
    | 'onDurationChange'
    | 'onDurationChangeCapture'
    | 'onEmptied'
    | 'onEmptiedCapture'
    | 'onEncrypted'
    | 'onEncryptedCapture'
    | 'onEnded'
    | 'onEndedCapture'
    | 'onLoadedData'
    | 'onLoadedDataCapture'
    | 'onLoadedMetadata'
    | 'onLoadedMetadataCapture'
    | 'onLoadStart'
    | 'onLoadStartCapture'
    | 'onPause'
    | 'onPauseCapture'
    | 'onPlay'
    | 'onPlayCapture'
    | 'onPlaying'
    | 'onPlayingCapture'
    | 'onProgress'
    | 'onProgressCapture'
    | 'onRateChange'
    | 'onRateChangeCapture'
    | 'onResize'
    | 'onResizeCapture'
    | 'onSeeked'
    | 'onSeekedCapture'
    | 'onSeeking'
    | 'onSeekingCapture'
    | 'onStalled'
    | 'onStalledCapture'
    | 'onSuspend'
    | 'onSuspendCapture'
    | 'onTimeUpdate'
    | 'onTimeUpdateCapture'
    | 'onVolumeChange'
    | 'onVolumeChangeCapture'
    | 'onWaiting'
    | 'onWaitingCapture'
    | 'onAuxClick'
    | 'onAuxClickCapture'
    | 'onClickCapture'
    | 'onContextMenu'
    | 'onContextMenuCapture'
    | 'onDoubleClick'
    | 'onDoubleClickCapture'
    | 'onDrag'
    | 'onDragCapture'
    | 'onDragEnd'
    | 'onDragEndCapture'
    | 'onDragEnter'
    | 'onDragEnterCapture'
    | 'onDragExit'
    | 'onDragExitCapture'
    | 'onDragLeave'
    | 'onDragLeaveCapture'
    | 'onDragOverCapture'
    | 'onDragStartCapture'
    | 'onDrop'
    | 'onDropCapture'
    | 'onMouseDown'
    | 'onMouseDownCapture'
    | 'onMouseEnter'
    | 'onMouseLeave'
    | 'onMouseMove'
    | 'onMouseMoveCapture'
    | 'onMouseOut'
    | 'onMouseOutCapture'
    | 'onMouseOver'
    | 'onMouseOverCapture'
    | 'onMouseUp'
    | 'onMouseUpCapture'
    | 'onSelect'
    | 'onSelectCapture'
    | 'onTouchCancel'
    | 'onTouchCancelCapture'
    | 'onTouchEnd'
    | 'onTouchEndCapture'
    | 'onTouchMove'
    | 'onTouchMoveCapture'
    | 'onTouchStart'
    | 'onTouchStartCapture'
    | 'onPointerDown'
    | 'onPointerDownCapture'
    | 'onPointerMove'
    | 'onPointerMoveCapture'
    | 'onPointerUp'
    | 'onPointerUpCapture'
    | 'onPointerCancel'
    | 'onPointerCancelCapture'
    | 'onPointerEnter'
    | 'onPointerEnterCapture'
    | 'onPointerLeave'
    | 'onPointerLeaveCapture'
    | 'onPointerOver'
    | 'onPointerOverCapture'
    | 'onPointerOut'
    | 'onPointerOutCapture'
    | 'onGotPointerCapture'
    | 'onGotPointerCaptureCapture'
    | 'onLostPointerCapture'
    | 'onLostPointerCaptureCapture'
    | 'onScroll'
    | 'onScrollCapture'
    | 'onWheel'
    | 'onWheelCapture'
    | 'onAnimationStart'
    | 'onAnimationStartCapture'
    | 'onAnimationEnd'
    | 'onAnimationEndCapture'
    | 'onAnimationIteration'
    | 'onAnimationIterationCapture'
    | 'onTransitionEnd'
    | 'onTransitionEndCapture'
    | 'width'
    | 'height'
    | 'accept'
    | 'acceptCharset'
    | 'allowFullScreen'
    | 'allowTransparency'
    | 'alt'
    | 'async'
    | 'autoComplete'
    | 'autoFocus'
    | 'autoPlay'
    | 'capture'
    | 'cellPadding'
    | 'cellSpacing'
    | 'charSet'
    | 'challenge'
    | 'checked'
    | 'classID'
    | 'cols'
    | 'colSpan'
    | 'content'
    | 'controls'
    | 'coords'
    | 'crossOrigin'
    | 'dateTime'
    | 'defer'
    | 'disabled'
    | 'download'
    | 'encType'
    | 'formAction'
    | 'formEncType'
    | 'formMethod'
    | 'formNoValidate'
    | 'formTarget'
    | 'frameBorder'
    | 'headers'
    | 'high'
    | 'href'
    | 'hrefLang'
    | 'htmlFor'
    | 'httpEquiv'
    | 'integrity'
    | 'keyParams'
    | 'keyType'
    | 'kind'
    | 'loop'
    | 'low'
    | 'manifest'
    | 'marginHeight'
    | 'marginWidth'
    | 'max'
    | 'maxLength'
    | 'media'
    | 'mediaGroup'
    | 'method'
    | 'min'
    | 'minLength'
    | 'multiple'
    | 'muted'
    | 'noValidate'
    | 'open'
    | 'optimum'
    | 'playsInline'
    | 'poster'
    | 'preload'
    | 'rel'
    | 'required'
    | 'reversed'
    | 'rows'
    | 'rowSpan'
    | 'sandbox'
    | 'scope'
    | 'scoped'
    | 'scrolling'
    | 'seamless'
    | 'shape'
    | 'size'
    | 'sizes'
    | 'src'
    | 'srcDoc'
    | 'srcLang'
    | 'srcSet'
    | 'step'
    | 'target'
    | 'useMap'
    | 'wmode'
    | 'wrap'
    | keyof PortableTextEditableProps
  > &
    React_2.RefAttributes<HTMLDivElement>
>

export declare type PortableTextEditableProps = {
  hotkeys?: HotkeyOptions
  onBeforeInput?: OnBeforeInputFn
  onPaste?: OnPasteFn
  onCopy?: OnCopyFn
  renderAnnotation?: RenderAnnotationFunction
  renderBlock?: RenderBlockFunction
  renderChild?: RenderChildFunction
  renderDecorator?: RenderDecoratorFunction
  renderPlaceholder?: () => React_2.ReactNode
  scrollSelectionIntoView?: ScrollSelectionIntoViewFunction
  selection?: EditorSelection
  spellCheck?: boolean
}

export declare class PortableTextEditor extends React_2.Component<
  PortableTextEditorProps,
  PortableTextEditorState
> {
  change$: EditorChanges
  keyGenerator: () => string
  maxBlocks: number | undefined
  portableTextFeatures: PortableTextFeatures
  readOnly: boolean
  slateInstance: PortableTextSlateEditor
  type: ArraySchemaType<PortableTextBlock>
  incomingPatches$?: PatchObservable
  private changeSubscription
  private editable?
  private pendingPatches
  private returnedPatches
  hasPendingLocalPatches: React_2.MutableRefObject<boolean | null>
  constructor(props: PortableTextEditorProps)
  componentWillUnmount(): void
  componentDidUpdate(prevProps: PortableTextEditorProps): void
  setEditable: (editable: EditableAPI) => void
  render(): string | JSX.Element
  syncValue: (userCallbackFn?: () => void) => void
  private flush
  private flushDebounced
  static activeAnnotations: (editor: PortableTextEditor) => PortableTextBlock[]
  static addAnnotation: (
    editor: PortableTextEditor,
    type: Type,
    value?:
      | {
          [prop: string]: unknown
        }
      | undefined
  ) =>
    | {
        spanPath: Path
        markDefPath: Path
      }
    | undefined
  static blur: (editor: PortableTextEditor) => void
  static delete: (
    editor: PortableTextEditor,
    selection: EditorSelection,
    options?: EditableAPIDeleteOptions
  ) => void | undefined
  static findDOMNode: (
    editor: PortableTextEditor,
    element: PortableTextBlock | PortableTextChild
  ) => Node | undefined
  static findByPath: (
    editor: PortableTextEditor,
    path: Path
  ) => [PortableTextBlock | PortableTextChild | undefined, Path | undefined] | []
  static focus: (editor: PortableTextEditor) => void
  static focusBlock: (editor: PortableTextEditor) => PortableTextBlock | undefined
  static focusChild: (editor: PortableTextEditor) => PortableTextChild | undefined
  static getPortableTextFeatures: (editor: PortableTextEditor) => PortableTextFeatures
  static getSelection: (editor: PortableTextEditor) => EditorSelection
  static getValue: (editor: PortableTextEditor) => PortableTextBlock[] | undefined
  static hasBlockStyle: (editor: PortableTextEditor, blockStyle: string) => boolean | undefined
  static hasListStyle: (editor: PortableTextEditor, listStyle: string) => boolean | undefined
  static isCollapsedSelection: (editor: PortableTextEditor) => boolean | undefined
  static isExpandedSelection: (editor: PortableTextEditor) => boolean | undefined
  static isMarkActive: (editor: PortableTextEditor, mark: string) => boolean | undefined
  static insertChild: (
    editor: PortableTextEditor,
    type: Type,
    value?:
      | {
          [prop: string]: unknown
        }
      | undefined
  ) => Path | undefined
  static insertBlock: (
    editor: PortableTextEditor,
    type: Type,
    value?:
      | {
          [prop: string]: unknown
        }
      | undefined
  ) => Path | undefined
  static isVoid: (
    editor: PortableTextEditor,
    element: PortableTextBlock | PortableTextChild
  ) => boolean | undefined
  static isObjectPath: (editor: PortableTextEditor, path: Path) => boolean
  static marks: (editor: PortableTextEditor) => string[] | undefined
  static select: (editor: PortableTextEditor, selection: EditorSelection | null) => void
  static removeAnnotation: (editor: PortableTextEditor, type: Type) => void | undefined
  static toggleBlockStyle: (editor: PortableTextEditor, blockStyle: string) => void | undefined
  static toggleList: (editor: PortableTextEditor, listStyle: string) => void
  static toggleMark: (editor: PortableTextEditor, mark: string) => void
}

/**
 * Props for the PortableTextEditor component
 *
 * @public
 */
/**
 * Props for the PortableTextEditor component
 *
 * @public
 */
export declare type PortableTextEditorProps = PropsWithChildren<{
  /**
   * Function that gets called when the editor changes the value
   */
  onChange: (change: EditorChange) => void
  /**
   * (Compiled or raw JSON) schema type for the portable text field
   */
  type: ArraySchemaType<PortableTextBlock> | RawType
  /**
   * Maximum number of blocks to allow within the editor
   */
  maxBlocks?: number | string
  /**
   * Whether or not the editor should be in read-only mode
   */
  readOnly?: boolean
  /**
   * The current value of the portable text field
   */
  value?: PortableTextBlock[]
  /**
   * Function used to generate keys for array items (`_key`)
   */
  keyGenerator?: () => string
  /**
   * Observable of incoming patches - used for undo/redo operations,
   * adjusting editor selections on concurrent editing and similar
   */
  incomingPatches$?: PatchObservable
}>

/**
 * @internal
 */
export declare interface PortableTextEditorState {
  invalidValueResolution: InvalidValueResolution | null
  selection: EditorSelection | null
  initialValue: Descendant[]
}

export declare type PortableTextFeature = {
  title: string
  value: string
  blockEditor?: {
    icon?: string | ComponentType<any>
    render?: ComponentType<any>
  }
  portableText?: {
    icon?: string | ComponentType<any>
    render?: ComponentType<any>
  }
  type: Type
}

export declare type PortableTextFeatures = {
  decorators: PortableTextFeature[]
  styles: PortableTextFeature[]
  annotations: PortableTextFeature[]
  lists: PortableTextFeature[]
  types: {
    block: ObjectSchemaType
    blockObjects: ObjectSchemaType[]
    inlineObjects: ObjectSchemaType[]
    portableText: ArraySchemaType<PortableTextBlock>
    span: ObjectSchemaType
    annotations: ObjectSchemaType[]
  }
}

export declare interface PortableTextSlateEditor extends ReactEditor {
  _key: 'editor'
  _type: 'editor'
  destroy: () => void
  createPlaceholderBlock: () => Descendant
  editable: EditableAPI
  history: History_2
  insertPortableTextData: (data: DataTransfer) => boolean
  insertTextOrHTMLData: (data: DataTransfer) => boolean
  isTextBlock: (value: unknown) => value is TextBlock
  isTextSpan: (value: unknown) => value is TextSpan
  isListBlock: (value: unknown) => value is ListItem
  readOnly: boolean
  maxBlocks: number | undefined
  /**
   * Increments selected list items levels, or decrements them if `reverse` is true.
   *
   * @param reverse - if true, decrement instead of incrementing
   * @returns True if anything was incremented in the selection
   */
  pteIncrementBlockLevels: (reverse?: boolean) => boolean
  /**
   * Toggle selected blocks as listItem
   *
   * @param listStyle - Style of list item to toggle on/off
   */
  pteToggleListItem: (listStyle: string) => void
  /**
   * Set selected block as listItem
   *
   * @param listStyle - Style of list item to set
   */
  pteSetListItem: (listStyle: string) => void
  /**
   * Unset selected block as listItem
   *
   * @param listStyle - Style of list item to unset
   */
  pteUnsetListItem: (listStyle: string) => void
  /**
   * Ends a list
   *
   * @returns True if a list was ended in the selection
   */
  pteEndList: () => boolean
  /**
   * Toggle marks in the selection
   *
   * @param mark - Mark to toggle on/off
   */
  pteToggleMark: (mark: string) => void
  /**
   * Test if a mark is active in the current selection
   *
   * @param mark - Mark to check whether or not is active
   */
  pteIsMarkActive: (mark: string) => boolean
  /**
   * Toggle the selected block style
   *
   * @param style - The style name
   *
   */
  pteToggleBlockStyle: (style: string) => void
  /**
   * Test if the current selection has a certain block style
   *
   * @param style - The style name
   *
   */
  pteHasBlockStyle: (style: string) => boolean
  /**
   * Test if the current selection has a certain list style
   *
   * @param listStyle - Style name to check whether or not the selection has
   *
   */
  pteHasListStyle: (style: string) => boolean
  /**
   * Try to expand the current selection to a word
   */
  pteExpandToWord: () => void
  /**
   * Use hotkeys
   */
  pteWithHotKeys: (event: React.KeyboardEvent<HTMLDivElement>) => void
  /**
   * Undo
   */
  undo: () => void
  /**
   * Redo
   */
  redo: () => void
}

export declare type PortableTextType = Type & {
  options?: {
    modal?: {
      type?: 'dialog' | 'popover'
      width?: number | number[] | 'auto'
    }
    sortable?: boolean
    layout?: 'grid'
  }
  styles?: {
    title: string
    value: string
  }[]
}

export declare type RawType = {
  type: string
  name: string
  title?: string
  description?: string
  readOnly?: boolean
  of?: Type[] | RawType[]
  options?: Record<string, any> | null
  fields?: Type[] | RawType[]
  [prop: string]: any
}

export declare type ReadyChange = {
  type: 'ready'
}

export declare type RedoChange = {
  type: 'redo'
  patches: Patch[]
  timestamp: Date
}

export declare type RenderAnnotationFunction = (
  value: PortableTextBlock,
  type: ObjectSchemaType,
  attributes: RenderAttributes,
  defaultRender: () => JSX.Element,
  ref: React.RefObject<HTMLSpanElement>
) => JSX.Element

export declare type RenderAttributes = {
  annotations?: PortableTextBlock[]
  focused: boolean
  level?: number
  listItem?: string
  path: Path
  selected: boolean
  style?: string
}

export declare type RenderBlockFunction = (
  value: PortableTextBlock,
  type: ObjectSchemaType,
  attributes: RenderAttributes,
  defaultRender: (val: PortableTextBlock) => JSX.Element,
  ref: React.RefObject<HTMLDivElement>
) => JSX.Element

export declare type RenderChildFunction = (
  value: PortableTextChild,
  type: ObjectSchemaType,
  attributes: RenderAttributes,
  defaultRender: (val: PortableTextChild) => JSX.Element,
  ref: React.RefObject<HTMLSpanElement>
) => JSX.Element

export declare type RenderDecoratorFunction = (
  value: string,
  type: {
    title: string
  },
  attributes: RenderAttributes,
  defaultRender: () => JSX.Element,
  ref: React.RefObject<HTMLSpanElement>
) => JSX.Element

export declare type ScrollSelectionIntoViewFunction = (
  editor: PortableTextEditor,
  domRange: globalThis.Range
) => void

export declare type SelectionChange = {
  type: 'selection'
  selection: EditorSelection
}

export declare type SetIfMissingPatch = {
  path: Path
  origin?: Origin
  type: 'setIfMissing'
  value: JSONValue
}

export declare type SetPatch = {
  path: Path
  type: 'set'
  origin?: Origin
  value: JSONValue
}

export declare interface TextBlock {
  _type: string
  _key: string
  children: PortableTextChild[]
  markDefs: MarkDef[]
  listItem?: string
  style?: string
  level?: number
}

export declare type TextSpan = {
  _key: string
  _type: 'span'
  text: string
  marks: string[]
}

export declare type Type = {
  type: Type
  name: string
  title: string
  description?: string
  readOnly?: boolean
  of: ArraySchemaType['of']
  options: Record<string, any> | null
  fields?: Type[]
  [prop: string]: any
  jsonType: 'array'
}

export declare type UndoChange = {
  type: 'undo'
  patches: Patch[]
  timestamp: Date
}

export declare type UnsetChange = {
  type: 'unset'
  previousValue: PortableTextBlock[]
}

export declare type UnsetPatch = {
  path: Path
  origin?: Origin
  type: 'unset'
}

/**
 * Get the current editor object from the React context.
 */
export declare const usePortableTextEditor: () => PortableTextEditor

/**
 * Get the current editor selection from the React context.
 */
export declare const usePortableTextEditorSelection: () => EditorSelection

export declare type ValueChange = {
  type: 'value'
  value: PortableTextBlock[] | undefined
}

export {}
